<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rotating Gift Boxes</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #111827;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .scene-container {
            width: 90%;
            max-width: 600px;
            height: 400px;
            margin: 2rem 0;
            border-radius: 1rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            background-color: #ffffff;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }
        .scene-container:active {
            cursor: grabbing;
        }
        canvas {
            display: block;
        }
        .scene-title {
            position: absolute;
            top: 1rem;
            left: 1.5rem;
            font-size: 1.25rem;
            font-weight: 700;
            color: #374151;
            z-index: 10;
            pointer-events: none; /* Make sure title doesn't interfere with mouse events */
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="text-center my-8">
        <h1 class="text-4xl font-bold text-gray-800">Interactive 3D Gift Kits</h1>
        <p class="text-lg text-gray-600 mt-2">Click and drag to rotate each box.</p>
    </div>

    <!-- Container for the first (small gift) box -->
    <div id="scene1-container" class="scene-container">
        <div class="scene-title">Mini Kit</div>
    </div>

    <!-- Container for the second (medium) box -->
    <div id="scene2-container" class="scene-container">
        <div class="scene-title">Regular Kit</div>
    </div>

    <!-- Container for the third (large) box -->
    <div id="scene3-container" class="scene-container">
        <div class="scene-title">Gold Kit</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Global Setup ---
        const scenes = [];

        // --- Scene Creation Function ---
        // This function sets up a complete Three.js scene in a given container.
        function createScene(containerId, options) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container with id ${containerId} not found.`);
                return;
            }

            // 1. Scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // 2. Camera
            const fov = 75;
            const aspect = container.clientWidth / container.clientHeight;
            const near = 0.1;
            const far = 100;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = options.cameraZ;

            // 3. Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // 5. Model
            const model = createGiftBox(options.size, options.color, options.ribbonColor);
            model.rotation.x = 0.25; // Initial angle
            model.rotation.y = -0.5; // Initial angle
            scene.add(model);
            
            // Store scene components for the animation loop and interaction
            const sceneObject = {
                container,
                scene,
                camera,
                renderer,
                model,
                isMouseDown: false,
                lastMouseX: 0,
                lastMouseY: 0,
            };
            scenes.push(sceneObject);

            // --- Interactivity ---
            addMouseHandlers(sceneObject);
        }

        // --- Model Creation Functions ---

        // Creates a simple box geometry and material with higher detail
        function createSimpleBox(size, color) {
            // Increased segments from 1,1,1 to 10,10,10 for a smoother surface
            const geometry = new THREE.BoxGeometry(size, size, size, 10, 10, 10);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.1
            });
            return new THREE.Mesh(geometry, material);
        }

        // Creates a complete gift box with ribbon and bow
        function createGiftBox(size, boxColor, ribbonColor) {
            const group = new THREE.Group();

            // Main Box
            const box = createSimpleBox(size, boxColor);
            group.add(box);

            // Yellow Ribbon Material - less metallic
            const ribbonMaterial = new THREE.MeshStandardMaterial({
                color: ribbonColor,
                metalness: 0.1,
                roughness: 0.6,
            });
            const ribbonWidth = size * 0.2;
            const ribbonOffset = size * 1.05; // Slightly larger to avoid z-fighting

            // Ribbons with more segments for a smoother look
            const ribbonSegments = 4;
            const horizontalGeom = new THREE.BoxGeometry(ribbonOffset, ribbonWidth, ribbonOffset, ribbonSegments, ribbonSegments, ribbonSegments);
            const horizontalRibbon = new THREE.Mesh(horizontalGeom, ribbonMaterial);
            group.add(horizontalRibbon);
            
            const verticalGeom = new THREE.BoxGeometry(ribbonWidth, ribbonOffset, ribbonOffset, ribbonSegments, ribbonSegments, ribbonSegments);
            const verticalRibbon = new THREE.Mesh(verticalGeom, ribbonMaterial);
            group.add(verticalRibbon);

            // Bow on top - with higher definition geometry
            const bowTieGroup = new THREE.Group();
            // Increased segments for a smoother sphere
            const knotGeom = new THREE.SphereGeometry(ribbonWidth * 0.7, 32, 32);
            const knot = new THREE.Mesh(knotGeom, ribbonMaterial);
            
            const loopSize = ribbonWidth * 1.5;
            // Increased segments for a smoother torus
            const loopGeom = new THREE.TorusGeometry(loopSize * 0.6, ribbonWidth * 0.25, 32, 100);
            
            const leftLoop = new THREE.Mesh(loopGeom, ribbonMaterial);
            leftLoop.position.x = -loopSize * 0.6;
            leftLoop.rotation.y = Math.PI / 2;
            leftLoop.rotation.z = -Math.PI / 6;

            const rightLoop = new THREE.Mesh(loopGeom, ribbonMaterial);
            rightLoop.position.x = loopSize * 0.6;
            rightLoop.rotation.y = -Math.PI / 2;
            rightLoop.rotation.z = -Math.PI / 6;

            bowTieGroup.add(knot, leftLoop, rightLoop);
            bowTieGroup.position.y = size / 2 + ribbonWidth * 0.3;
            group.add(bowTieGroup);

            return group;
        }

        // --- Interaction Handlers ---
        function addMouseHandlers(sceneObject) {
            const { container, model } = sceneObject;

            const onPointerDown = (e) => {
                sceneObject.isMouseDown = true;
                sceneObject.lastMouseX = e.clientX || e.touches[0].clientX;
                sceneObject.lastMouseY = e.clientY || e.touches[0].clientY;
            };

            const onPointerUp = () => {
                sceneObject.isMouseDown = false;
            };

            const onPointerMove = (e) => {
                if (!sceneObject.isMouseDown) return;
                e.preventDefault();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                const deltaX = clientX - sceneObject.lastMouseX;
                const deltaY = clientY - sceneObject.lastMouseY;
                
                model.rotation.y += deltaX * 0.01;
                model.rotation.x += deltaY * 0.01;
                
                sceneObject.lastMouseX = clientX;
                sceneObject.lastMouseY = clientY;
            };

            container.addEventListener('mousedown', onPointerDown);
            container.addEventListener('mouseup', onPointerUp);
            container.addEventListener('mouseleave', onPointerUp);
            container.addEventListener('mousemove', onPointerMove);
            
            container.addEventListener('touchstart', onPointerDown, { passive: false });
            container.addEventListener('touchend', onPointerUp);
            container.addEventListener('touchmove', onPointerMove, { passive: false });
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            scenes.forEach(sceneObj => {
                // Auto-rotate if not being dragged
                if (!sceneObj.isMouseDown) {
                    sceneObj.model.rotation.y += 0.005;
                }
                sceneObj.renderer.render(sceneObj.scene, sceneObj.camera);
            });
        }

        // --- Window Resize Handler ---
        function onWindowResize() {
            scenes.forEach(sceneObj => {
                const { container, camera, renderer } = sceneObj;
                const width = container.clientWidth;
                const height = container.clientHeight;

                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
        }
        window.addEventListener('resize', onWindowResize);

        // --- Initialize all scenes ---
        function init() {
            const yellowColor = 0xFFFF00; // Changed from gold to yellow
            // Scene 1: Grey Box
            createScene('scene1-container', { size: 2, color: 0x808080, ribbonColor: yellowColor, cameraZ: 5 });
            // Scene 2: Blue Box
            createScene('scene2-container', { size: 3, color: 0x2563eb, ribbonColor: yellowColor, cameraZ: 7 });
            // Scene 3: Violet Box
            createScene('scene3-container', { size: 4, color: 0x8a2be2, ribbonColor: yellowColor, cameraZ: 9 });
            animate();
        }

        init();
    </script>
</body>
</html>
